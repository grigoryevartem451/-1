# Задача 1 – упражнения с malloc и сложными однострочными выражениями в C с присваиваниями внутри
## постановка задачи
Внутри функции int main(void) { /.../ } определите указатель: double ***pointer = NULL; Инициализируйте этот указатель адресом другого указателя типа double **, который указывает, в свою очередь, на переменную double. Используйте pointer для записи и чтения в эту переменную значения 2. При этом выполните следующее: - Используйте функции типа *alloc(...) для выделения оперативной памяти под динамические объекты; - Запишите и выведите число 2 на экран, используя указатель double ***pointer = NULL;;

# Математическая модель
Трёхуровневая система указателей:
pointer → double** → double* → double.
В памяти хранится значение 2.0.
Доступ к переменной и её модификация выполняется исключительно через pointer.

# индетификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| pointer | double*** | Указатель тройного уровня для доступа к переменной double |
| malloc | функция | Выделение динамической памяти |
| free | функция | Освобождение динамической памяти |
| printf | функция | Вывод значения на экран |
# код
```c
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    double ***pointer = NULL;
    
    pointer = malloc(sizeof(double**));
    *pointer = malloc(sizeof(double*));
    **pointer = malloc(sizeof(double));
    
    ***pointer = 2.0;
    printf("%f\n", ***pointer);
    
    free(**pointer);
    free(*pointer);
    free(pointer);
    
    return 0;
}
```
## результат
<img width="156" height="23" alt="image" src="https://github.com/user-attachments/assets/01b737b0-2510-430f-9d04-963bcce0683f" />

# задача 2

## постановка задачи
Напишите программу, которая создает одномерный динамический массив из чисел с плавающей точкой двойной точности, заполняет его значениями с клавиатуры и выводит все элементы массива, используя арифметику указателей (оператор +), а не оператор доступа к элементам массива [].

## математическая модель

Создаётся одномерный динамический массив элементов типа double.

Доступ к элементам массива осуществляется через арифметику указателей:

(arr + i) — адрес элемента,

*(arr + i) — значение элемента.

Таким образом, обход массива происходит без использования синтаксиса arr[i].

# индентифакоты
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| n | int | Размер массива |
| arr | float* | Указатель на массив |
| i | int | Счетчик цикла |
| malloc | функция | Выделение памяти |
| free | функция | Освобождение памяти |
| printf | функция | Вывод на экран |
| scanf | функция | Ввод с клавиатуры |

# код
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n;
    printf("Введите размер массива: ");
    scanf("%d", &n);
    
    float *arr = (float*)malloc(n * sizeof(float));
    
    printf("Введите %d чисел:\n", n);
    for(int i = 0; i < n; i++) {
        scanf("%f", arr + i);
    }
    
    printf("Элементы массива:\n");
    for(int i = 0; i < n; i++) {
        printf("%.2f ", *(arr + i));
    }
    printf("\n");
    
    free(arr);
    return 0;
}
```
# результат
<img width="328" height="103" alt="image" src="https://github.com/user-attachments/assets/6f6b09e8-c0a8-464f-88a2-ee1a6d8f432f" >

# задание 3
## постановка задачи
Выделите память под двумерный динамический массив двумя способами:
1. Классический способ: выделите память для массива указателей на строки и отдельно для каждой строки в
цикле. Это позволит гибко управлять памятью, но при этом каждая строка будет находиться в отдельной части
памяти.
3
2. Непрерывный способ (contiguous memory allocation): выделите память для всего массива одним вызовом
malloc, что позволит разместить весь массив в непрерывном блоке памяти, улучшая производительность и
снижая риск внешней фрагментации памяти.

# математическая модель
Массив имеет форму n x m.

В классическом подходе создаётся массив указателей на строки (int**), каждая строка выделяется отдельно.

В непрерывном подходе создаётся один блок памяти размером n*m, а доступ к элементу осуществляется по формуле: arr[i][j] ↔ *(arr + i * m + j)

# индентификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| rows | int | Количество строк массива |
| cols | int | Количество столбцов массива |
| arr | int** | Указатель на массив указателей |
| data | int* | Указатель на блок данных |
| i | int | Счетчик цикла |
| malloc | функция | Выделение динамической памяти |
| free | функция | Освобождение динамической памяти |

# код
```c
// Способ 1: Классический
#include <stdlib.h>

int main(void) {
    int rows = 3, cols = 4;
    int **arr = (int**)malloc(rows * sizeof(int*));
    
    for (int i = 0; i < rows; i++) {
        arr[i] = (int*)malloc(cols * sizeof(int));
    }
    
    for (int i = 0; i < rows; i++) {
        free(arr[i]);
    }
    free(arr);
    
    return 0;
}

// Способ 2: Непрерывный
#include <stdlib.h>

int main(void) {
    int rows = 3, cols = 4;
    int **arr = (int**)malloc(rows * sizeof(int*) + rows * cols * sizeof(int));
    int *data = (int*)(arr + rows);
    
    for (int i = 0; i < rows; i++) {
        arr[i] = data + i * cols;
    }
    
    free(arr);
    return 0;
}
```

# результат
<img width="219" height="177" alt="image" src="https://github.com/user-attachments/assets/b2d02088-4cb8-4802-a04b-0486278f7897" />

# Задача 4 - поменять местами два числа через указатели
## постановка задачи
Написать программу, которая использует функцию для обмена значениями двух переменных через указатели.
# Математическая модель
Имеются две переменные a и b.

Через функцию swap(int *x, int *y) выполняется обмен значениями:

временно сохраняем значение *x в переменную temp,

присваиваем *x = *y,

присваиваем *y = temp.

Таким образом, значения переменных меняются местами без прямого использования их имён в теле программы.

# индетификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| a | int* | Указатель на первую переменную |
| b | int* | Указатель на вторую переменную |
| temp | int | Временная переменная для обмена |
| x | int | Первая переменная |
| y | int | Вторая переменная |
| swap | функция | Функция обмена значений |
| printf | функция | Вывод на экран |

# код
```c
#include <stdio.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void) {
    int x = 5, y = 10;
    
    printf("До обмена: x = %d, y = %d\n", x, y);
    swap(&x, &y);
    printf("После обмена: x = %d, y = %d\n", x, y);
    
    return 0;
}
```
# результат
<img width="370" height="52" alt="image" src="https://github.com/user-attachments/assets/8296544e-0f9f-4d51-b6e5-4c1d2351ed28" />

# Задача 5 - поиск максимального элемента массива с помощью указателей

# постановка задачи

Создать функцию, которая принимает массив целых чисел и его размер, а затем возвращает указатель на максимальный элемент массива.

# Математическая модель

Задаётся массив arr размером n.

Используется указатель для обхода массива.

При сравнении элементов сохраняется адрес текущего максимального значения.

Функция возвращает указатель на элемент с максимальным значением.

# индетификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| arr | int* | Указатель на массив |
| size | int | Размер массива |
| max | int | Максимальное значение |
| max_ptr | int* | Указатель на максимальный элемент |
| i | int | Счетчик цикла |
| find_max | функция | Поиск максимального значения |
| find_max_ptr | функция | Поиск указателя на максимальный элемент |
| printf | функция | Вывод на экран |

# код
```c
#include <stdio.h>

int find_max(int *arr, int size) {
    int max = *arr;
    for (int i = 1; i < size; i++) {
        if (*(arr + i) > max) {
            max = *(arr + i);
        }
    }
    return max;
}

int main(void) {
    int arr[] = {3, 7, 2, 9, 1, 8, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    int max = find_max(arr, size);
    printf("Максимальный элемент: %d\n", max);
    
    return 0;
}
```
# результат
<img width="276" height="24" alt="image" src="https://github.com/user-attachments/assets/135ae4d8-68df-42e5-a060-078390a215da" />

# Задача 6 - реверс массива через указатели

# постановка задачи

Реализовать функцию, которая переворачивает массив целых чисел, используя указатели для перемещения по элементам.

# математическая модель
Имеется массив arr длиной n.

Используются два указателя:

left — указывает на первый элемент,

right — указывает на последний элемент.

Меняем значения, на которые указывают left и right, затем сдвигаем указатели навстречу друг другу.

Алгоритм завершается, когда left >= right.
# индентификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| arr | int* | Указатель на массив |
| size | int | Размер массива |
| start | int* | Указатель на начало массива |
| end | int* | Указатель на конец массива |
| temp | int | Временная переменная для обмена |
| i | int | Счетчик цикла |
| reverse_array | функция | Функция переворота массива |
| printf | функция | Вывод на экран |

# код
```c
#include <stdio.h>

void reverse_array(int *arr, int size) {
    int *start = arr;
    int *end = arr + size - 1;
    
    while (start < end) {
        int temp = *start;
        *start = *end;
        *end = temp;
        
        start++;
        end--;
    }
}

int main(void) {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    printf("Исходный массив: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    reverse_array(arr, size);
    
    printf("Перевернутый массив: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```
# результат
<img width="385" height="57" alt="image" src="https://github.com/user-attachments/assets/064511a2-de63-4d8d-b52b-53e031560953" />

# Задача 7 - поиск подстроки в строке через указатели

# постановка задачи
Реализовать функцию, которая находит первое вхождение одной строки в другую, используя указатели вместо индексов для доступа к символам строки.

# математическая модель
Даны две строки:

str — исходная строка,

substr — подстрока.

Для поиска используется перебор:

выбираем позицию в str,

проверяем совпадение символов с substr с помощью указателей.

Если найдено совпадение — возвращается указатель на начало подстроки в строке.

Если совпадения нет — возвращается NULL.

# индентификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| str1 | char* | Указатель на первую строку |
| str2 | char* | Указатель на вторую строку |
| p1 | char* | Указатель для перемещения по str1 |
| p2 | char* | Временный указатель для сравнения |
| p3 | char* | Временный указатель для str2 |
| result | char* | Указатель на найденную подстроку |
| find_substring | функция | Поиск подстроки в строке |
| printf | функция | Вывод на экран |

# код
```c
#include <stdio.h>

char* find_substring(char *str1, char *str2) {
    char *p1 = str1;
    char *p2, *p3;
    
    while (*p1) {
        p2 = p1;
        p3 = str2;
        
        while (*p2 && *p3 && *p2 == *p3) {
            p2++;
            p3++;
        }
        
        if (!*p3) {
            return p1;
        }
        
        p1++;
    }
    
    return NULL;
}

int main(void) {
    char str1[] = "Hello, world!";
    char str2[] = "world";
    
    char *result = find_substring(str1, str2);
    
    if (result != NULL) {
        printf("Подстрока найдена: %s\n", result);
    } else {
        printf("Подстрока не найдена\n");
    }
    
    return 0;
}
```
# результат
<img width="361" height="51" alt="image" src="https://github.com/user-attachments/assets/3b00d0ae-d08b-4417-8e96-92833692e005" />

# Задача 8 - копирование строки через указатели

# постановка задачи
Написать функцию, которая копирует одну строку в другую, используя указатели вместо встроенной функции strcpy.

# математическая модель
Даны две строки:

src — исходная строка,

dest — строка-приёмник.

Используется указатель для последовательного обхода символов src.

Копирование выполняется до тех пор, пока не встретится завершающий символ '\0'.

В конце в dest записывается символ '\0.

# индентификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| dest | char* | Указатель на строку назначения |
| src | char* | Указатель на исходную строку |
| my_strcpy | функция | Функция копирования строки |
| printf | функция | Вывод на экран |

# код
```c
#include <stdio.h>

void my_strcpy(char *dest, char *src) {
    while (*src) {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';
}

int main(void) {
    char src[] = "eshkere";
    char dest[50];
    
    my_strcpy(dest, src);
    
    printf("Исходная строка: %s\n", src);
    printf("Скопированная строка: %s\n", dest);
    
    return 0;
}
```
# результат
<img width="403" height="51" alt="image" src="https://github.com/user-attachments/assets/6e57b0a8-a4e3-4135-a709-54930c403796" />

# Задача 9 - подсчет числа пробелов в строке

# постановка задачи
Написать функцию, которая подсчитывает количество пробелов в строке, используя указатели для перемещения по
символам строки.

# математическая модель

Задаётся строка str.

Указатель последовательно проходит по каждому символу.

Если текущий символ равен ' ', счётчик увеличивается на 1.

В конце возвращается количество пробелов.

# индентификаторы

| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| str | char* | Указатель на строку |
| ptr | char* | Указатель для перемещения по строке |
| count | int | Счетчик пробелов |
| spaces | int | Количество пробелов |
| count_spaces | функция | Функция подсчета пробелов |
| printf | функция | Вывод на экран |

#код
```c
#include <stdio.h>

int count_spaces(char *str) {
    int count = 0;
    
    while (*str) {
        if (*str == ' ') {
            count++;
        }
        str++;
    }
    
    return count;
}

int main(void) {
    char str[] = "eshkere, this is a test string";
    
    int spaces = count_spaces(str);
    
    printf("Строка: \"%s\"\n", str);
    printf("Количество пробелов: %d\n", spaces);
    
    return 0;
}
```
# результат
<img width="413" height="48" alt="image" src="https://github.com/user-attachments/assets/efc76962-c9d2-4554-b2ba-4c2824cd7a3e" />

# Задача 10 - указатель на функцию: сортировка массива

# постановка задачи
Реализуйте функцию сортировки одномерного массива, которая принимает указатель на функцию сравнения. Эта
функция сравнения должна определять порядок сортировки — по возрастанию или по убыванию. Внутри функции
сортировки реализуйте обмен элементов массива местами с помощью функции swap, которая работает через указатели.

# математическая модель
Используется массив arr длиной n.

Для сравнения элементов передаётся функция compare(int a, int b), возвращающая истину при необходимости поменять местами элементы.

Функция сортировки перебирает элементы массива и вызывает swap, если порядок нарушен.

В результате массив сортируется либо по возрастанию, либо по убыванию.

# индентификаторы
| Имя переменной | Тип данных | Смысловое обозначение |
|----------------|------------|----------------------|
| arr | int* | Указатель на массив |
| size | int | Размер массива |
| a | int* | Указатель на первый элемент для обмена |
| b | int* | Указатель на второй элемент для обмена |
| temp | int | Временная переменная для обмена |
| i, j | int | Счетчики циклов |
| compare | function pointer | Указатель на функцию сравнения |
| swap | функция | Функция обмена элементов |
| ascending | функция | Функция сравнения для возрастания |
| descending | функция | Функция сравнения для убывания |
| bubble_sort | функция | Функция сортировки |
| print_array | функция | Функция вывода массива |
| printf | функция | Вывод на экран |

# код

```c
#include <stdio.h>


void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}


int ascending(int a, int b) {
    return a > b;
}

int descending(int a, int b) {
    return a < b;
}


void bubble_sort(int *arr, int size, int (*compare)(int, int)) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (compare(*(arr + j), *(arr + j + 1))) {
                swap(arr + j, arr + j + 1);
            }
        }
    }
}


void print_array(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", *(arr + i));
    }
    printf("\n");
}

int main(void) {
    int arr[] = {5, 2, 8, 1, 9, 3};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    printf("Исходный массив: ");
    print_array(arr, size);
    
    
    bubble_sort(arr, size, ascending);
    printf("По возрастанию: ");
    print_array(arr, size);
    
   
    bubble_sort(arr, size, descending);
    printf("По убыванию:    ");
    print_array(arr, size);
    
    return 0;
}
```
# результат
<img width="349" height="70" alt="image" src="https://github.com/user-attachments/assets/789cafdc-a40b-48fd-be70-ca0e43af223a" />

# автор
Григорьев Артём 
Группа ПОО
